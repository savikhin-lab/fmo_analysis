import matplotlib.pyplot as plt
import numpy as np
from pathlib import Path
from typing import List, Tuple, Dict
from .util import parse_conf_file, Pigment, Config


def delete_pigment_ham(ham: np.ndarray, delete: int) -> np.ndarray:
    """Remove the pigment from the Hamiltonian (set row and column to zero)."""
    new_ham = ham.copy()
    new_ham[delete, :] = 0
    new_ham[:, delete] = 0
    return new_ham


def delete_pigment_pigs(pigs: List[Pigment], delete: int) -> List[Pigment]:
    """Remove the pigment from the list of pigments (set mu = 0)."""
    new_pigs = [p for p in pigs]
    p = new_pigs[delete]
    p.mu *= 0
    new_pigs[delete] = p
    return new_pigs


def delete_pigment(config: Config, ham: np.ndarray, pigs: List[Pigment]) -> Tuple[np.ndarray, List[Pigment]]:
    """Returns the Hamiltonian and pigments with the pigment deleted."""
    if config.delete_pig > 0:
        ham = delete_pigment_ham(ham, config.delete_pig)
        pigs = delete_pigment_pigs(pigs, config.delete_pig)
    return ham, pigs


def make_stick_spectrum(config: Config, ham: np.ndarray, pigs: List[Pigment]) -> Dict:
    """Computes the stick spectra and eigenvalues/eigenvectors for the system."""
    ham, pigs = delete_pigment(config, ham, pigs)
    n_pigs = ham.shape[0]
    e_vals, e_vecs = np.linalg.eig(ham)
    pig_mus = np.zeros((n_pigs, 3))
    for i, p in enumerate(pigs):
        pig_mus[i, :] = pigs[i].mu
    exciton_mus = np.zeros_like(pig_mus)
    stick_abs = np.zeros(n_pigs)
    stick_cd = np.zeros(n_pigs)
    for i in range(n_pigs):
        exciton_mus[i, :] = np.sum(np.repeat(e_vecs[:, i], 3).reshape((n_pigs, 3)) * pig_mus, axis=0)
        stick_abs[i] = np.dot(exciton_mus[i], exciton_mus[i])
        for j in range(n_pigs):
            for k in range(n_pigs):
                r = pigs[j].pos - pigs[k].pos
                mu_cross = np.cross(pigs[j].mu, pigs[k].mu)
                stick_cd[i] += e_vecs[j, i] * e_vecs[k, i] * np.dot(r, mu_cross)
    out = {
        "ham_deleted": ham,
        "pigs_deleted": pigs,
        "e_vals": e_vals,
        "e_vecs": e_vecs,
        "exciton_mus": exciton_mus,
        "stick_abs": stick_abs,
        "stick_cd": stick_cd
    }
    return out
    

def make_stick_spectra(config: Config, cf: List[Path]) -> List[Dict]:
    """Computes the OD and CD stick spectra for a single Hamiltonian and set of pigments."""
    results = []
    for c in cf:
        ham, pigs = parse_conf_file(config, c)
        stick = make_stick_spectrum(config, ham, pigs)
        stick["file"] = c
        results.append(stick)
    return results


def save_stick_spectrum(parent_dir: Path, stick: Dict):
    """Saves the result of computing a stick spectrum to disk.
    
    This saves 5 files:
    - 'energies.csv'
    - 'eigenvectors.csv'
    - 'exciton_mus.csv'
    - 'stick_abs.csv'
    - 'stick_cd.csv'

    The convention for the data stored in each file is that row X in each file
    corresponds to the same exciton. For example, the first entry in 'energies.csv'
    is the energy of the first exciton, and the first ROW in 'eigenvectors.csv' is
    the eigenvector of the first exciton. This means that the array in 'eigenvectors.csv'
    is stored in the transposed order from how it is generated by np.linalg.eig().
    """
    dir_name = stick["file"].stem + "-stick"
    outdir = parent_dir / dir_name
    outdir.mkdir(exist_ok=True)
    np.savetxt(outdir / "energies.csv", stick["e_vals"], delimiter=",")
    np.savetxt(outdir / "eigenvectors.csv", stick["e_vecs"].T, delimiter=",")
    np.savetxt(outdir / "exciton_mus.csv", stick["exciton_mus"], delimiter=",")
    np.savetxt(outdir / "stick_abs.csv", stick["stick_abs"], delimiter=",")
    np.savetxt(outdir / "stick_cd.csv", stick["stick_cd"], delimiter=",")


def save_stick_spectra(outdir: Path, sticks: List[Dict]) -> None:
    """Saves results of stick spectra computation.
    
    The directory structure is:
    <output directory>/
        stick_spectra/
            conf*/
                <result>
    """
    stick_dir = outdir / "stick_spectra"
    stick_dir.mkdir(exist_ok=True)
    for s in sticks:
        save_stick_spectrum(stick_dir, s)


def make_broadened_spectrum(config: Config, stick: Dict) -> Dict:
    """Make the broadened spectrum from a stick spectrum."""
    x = np.arange(config.xfrom, config.xto, config.xstep, dtype=np.float64)
    abs = np.zeros_like(x)
    cd = np.zeros_like(x)
    dip_strengths = stick["stick_abs"]
    rot_strengths = stick["stick_cd"]
    energies = stick["e_vals"]
    sigma_squared = config.bandwidth**2 / (4 * np.log(2))
    for exc in range(len(energies)):
        abs += dip_strengths[exc] * np.exp(-(x - energies[exc])**2 / sigma_squared)
        cd += rot_strengths[exc] * np.exp(-(x - energies[exc])**2 / sigma_squared)
    return {"abs": abs, "cd": cd, "x": x}


def make_broadened_spectra(config: Config, sticks: Dict) -> Dict:
    """Make broadened spectra from the stick spectra."""
    individual_spectra = []
    for s in sticks:
        b = make_broadened_spectrum(config, s)
        b["file"] = s["file"]
        individual_spectra.append(b)
    avg_abs = np.mean([s["abs"] for s in individual_spectra], axis=0)
    avg_cd = np.mean([s["cd"] for s in individual_spectra], axis=0)
    return {"spectra": individual_spectra, "avg_abs": avg_abs, "avg_cd": avg_cd}


def save_broadened_spectra(outdir: Path, b_specs: List[Dict]) -> None:
    """Save the results of computing the broadened spectra.
    
    The directory structure is:
    <output directory>/
        broadened_spectra/
            abs/
            cd/
            plots/
            avg_abs.csv
            avg_cd.csv
            avg.png
    """
    b_dir = outdir / "broadened_spectra"
    b_dir.mkdir(exist_ok=True)
    abs_dir = b_dir / "abs"
    abs_dir.mkdir(exist_ok=True)
    cd_dir = b_dir / "cd"
    cd_dir.mkdir(exist_ok=True)
    plots_dir = b_dir / "plots"
    plots_dir.mkdir(exist_ok=True)
    for s in b_specs["spectra"]:
        x = s["x"]
        abs = s["abs"]
        cd = s["cd"]
        stem = s["file"].stem
        np.savetxt(abs_dir / f"{stem}_abs.csv", np.stack((x, abs), axis=1), delimiter=",")
        np.savetxt(cd_dir / f"{stem}_cd.csv", np.stack((x, cd), axis=1), delimiter=",")
        save_stacked_plot(plots_dir / f"{stem}.png", x, abs, cd)
    x = b_specs["spectra"][0]["x"]
    abs_data = np.zeros((len(x), 2))
    abs_data[:, 0] = x
    abs_data[:, 1] = b_specs["avg_abs"]
    np.savetxt(b_dir / "avg_abs.csv", abs_data, delimiter=",")
    cd_data = np.zeros((len(x), 2))
    cd_data[:, 0] = x
    cd_data[:, 1] = b_specs["avg_cd"]
    np.savetxt(b_dir / "avg_cd.csv", cd_data, delimiter=",")
    save_stacked_plot(b_dir / "avg.png", x, abs_data[:, 1], cd_data[:, 1], title="Average")


def save_stacked_plot(path: Path, x: np.ndarray, abs: np.ndarray, cd: np.ndarray, **opts: Dict) -> None:
    """Save a plot with absorption and CD in the same figure."""
    fig, (ax_abs, ax_cd) = plt.subplots(2, 1, sharex=True)
    ax_abs.plot(x, abs)
    ax_abs.set(xlabel="", ylabel="Abs.")
    ax_abs.grid()
    ax_cd.plot(x, cd)
    ax_cd.set(xlabel="Wavenumbers", ylabel="CD")
    ax_cd.grid()
    try:
        ax_abs.set(title=opts["title"])
    except KeyError:
        pass
    fig.savefig(path)
    plt.close(fig)